<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>网络安全棋谱 - 多维度对抗系统</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: '微软雅黑', Arial, sans-serif;
            background: linear-gradient(135deg, #0f1419 0%, #1a2332 100%);
            min-height: 100vh;
            color: #fff;
            overflow-x: hidden;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }
        
        /* 开始界面 */
        #start-screen {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            text-align: center;
        }
        
        .title {
            font-size: 3em;
            font-weight: bold;
            margin-bottom: 20px;
            background: linear-gradient(90deg, #00d4ff, #ff0080);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 30px rgba(0,212,255,0.5);
        }
        
        .subtitle {
            font-size: 1.2em;
            color: #8b95a7;
            margin-bottom: 40px;
        }
        
        .role-selection {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 30px;
            margin-bottom: 40px;
        }
        
        .role-card {
            background: rgba(255,255,255,0.05);
            border: 2px solid rgba(255,255,255,0.1);
            border-radius: 15px;
            padding: 30px;
            cursor: pointer;
            transition: all 0.3s ease;
            width: 250px;
        }
        
        .role-card:hover {
            transform: translateY(-5px);
            border-color: rgba(0,212,255,0.5);
            background: rgba(0,212,255,0.1);
        }
        
        .role-card.selected {
            border-color: #00d4ff;
            background: rgba(0,212,255,0.2);
            box-shadow: 0 0 20px rgba(0,212,255,0.3);
        }
        
        .role-card h3 {
            font-size: 1.5em;
            margin-bottom: 15px;
        }
        
        .role-card p {
            color: #8b95a7;
            font-size: 0.9em;
            line-height: 1.5;
        }
        
        .start-btn {
            background: linear-gradient(90deg, #00d4ff, #0066ff);
            color: #fff;
            border: none;
            border-radius: 10px;
            padding: 15px 60px;
            font-size: 1.2em;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .start-btn:disabled {
            background: #444;
            cursor: not-allowed;
            opacity: 0.5;
        }
        
        .start-btn:not(:disabled):hover {
            transform: scale(1.05);
            box-shadow: 0 5px 20px rgba(0,212,255,0.4);
        }
        
        /* 游戏主界面 */
        #game-screen {
            display: none;
        }
        
        .game-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px;
            background: rgba(0,0,0,0.3);
            border-radius: 10px;
            margin-bottom: 20px;
        }
        
        .round-info {
            font-size: 1.3em;
            font-weight: bold;
        }
        
        .resource-panel {
            display: flex;
            gap: 30px;
        }
        
        .resource-item {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .resource-icon {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
        }
        
        .resource-value {
            font-size: 1.1em;
            font-weight: bold;
        }
        
        /* 多层次战场 */
        .battlefield-container {
            display: grid;
            grid-template-columns: 1fr 2fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .battlefield-layers {
            background: rgba(0,0,0,0.3);
            border-radius: 10px;
            padding: 20px;
        }
        
        .layer-title {
            font-size: 1.1em;
            font-weight: bold;
            margin-bottom: 15px;
            color: #00d4ff;
        }
        
        .layer-item {
            background: rgba(255,255,255,0.05);
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .layer-name {
            font-weight: bold;
        }
        
        .layer-status {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .status-bar {
            width: 100px;
            height: 8px;
            background: rgba(255,255,255,0.1);
            border-radius: 4px;
            overflow: hidden;
        }
        
        .status-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff0080, #00d4ff);
            transition: width 0.3s ease;
        }
        
        .status-value {
            font-size: 0.9em;
            color: #8b95a7;
        }
        
        /* 战术选择区 */
        .tactics-area {
            background: rgba(0,0,0,0.3);
            border-radius: 10px;
            padding: 20px;
        }
        
        .tactics-title {
            font-size: 1.2em;
            font-weight: bold;
            margin-bottom: 15px;
            text-align: center;
        }
        
        .tactics-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
        }
        
        .tactic-card {
            background: rgba(255,255,255,0.05);
            border: 2px solid rgba(255,255,255,0.1);
            border-radius: 8px;
            padding: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .tactic-card:hover {
            border-color: rgba(0,212,255,0.5);
            background: rgba(0,212,255,0.1);
        }
        
        .tactic-card.selected {
            border-color: #00d4ff;
            background: rgba(0,212,255,0.2);
        }
        
        .tactic-card.disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .tactic-name {
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .tactic-cost {
            font-size: 0.8em;
            color: #ff9800;
        }
        
        .tactic-desc {
            font-size: 0.8em;
            color: #8b95a7;
            margin-top: 5px;
        }
        
        /* 情报面板 */
        .intel-panel {
            background: rgba(0,0,0,0.3);
            border-radius: 10px;
            padding: 20px;
        }
        
        .intel-title {
            font-size: 1.1em;
            font-weight: bold;
            margin-bottom: 15px;
            color: #ffd700;
        }
        
        .intel-item {
            background: rgba(255,215,0,0.1);
            border-left: 3px solid #ffd700;
            padding: 10px;
            margin-bottom: 10px;
            font-size: 0.9em;
        }
        
        .intel-new {
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% { background: rgba(255,215,0,0.1); }
            50% { background: rgba(255,215,0,0.2); }
            100% { background: rgba(255,215,0,0.1); }
        }
        
        /* 操作日志 */
        .action-log {
            background: rgba(0,0,0,0.3);
            border-radius: 10px;
            padding: 20px;
            height: 300px;
            overflow-y: auto;
        }
        
        .log-title {
            font-size: 1.1em;
            font-weight: bold;
            margin-bottom: 15px;
            color: #00ff88;
        }
        
        .log-entry {
            padding: 8px;
            margin-bottom: 5px;
            border-left: 3px solid #00ff88;
            background: rgba(0,255,136,0.05);
            font-size: 0.9em;
        }
        
        .log-entry.attack {
            border-color: #ff0080;
            background: rgba(255,0,128,0.05);
        }
        
        .log-entry.defense {
            border-color: #00d4ff;
            background: rgba(0,212,255,0.05);
        }
        
        .log-entry.monitor {
            border-color: #ffd700;
            background: rgba(255,215,0,0.05);
        }
        
        /* 执行按钮 */
        .action-buttons {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 20px;
        }
        
        .execute-btn {
            background: linear-gradient(90deg, #00ff88, #00d4ff);
            color: #000;
            border: none;
            border-radius: 8px;
            padding: 12px 40px;
            font-size: 1.1em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .execute-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 5px 20px rgba(0,255,136,0.4);
        }
        
        .execute-btn:disabled {
            background: #444;
            cursor: not-allowed;
            opacity: 0.5;
        }
        
        /* 事件弹窗 */
        .event-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }
        
        .event-content {
            background: linear-gradient(135deg, #1a2332, #2a3442);
            border: 2px solid #00d4ff;
            border-radius: 15px;
            padding: 30px;
            max-width: 500px;
            text-align: center;
        }
        
        .event-title {
            font-size: 1.5em;
            font-weight: bold;
            margin-bottom: 15px;
            color: #ffd700;
        }
        
        .event-desc {
            margin-bottom: 20px;
            line-height: 1.5;
        }
        
        .event-impact {
            background: rgba(255,0,0,0.1);
            border: 1px solid rgba(255,0,0,0.3);
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 20px;
            color: #ff9800;
        }
        
        /* 结束界面 */
        #end-screen {
            display: none;
            text-align: center;
            padding: 40px;
        }
        
        .end-title {
            font-size: 2.5em;
            font-weight: bold;
            margin-bottom: 20px;
        }
        
        .victory {
            color: #00ff88;
            text-shadow: 0 0 20px rgba(0,255,136,0.5);
        }
        
        .defeat {
            color: #ff0080;
            text-shadow: 0 0 20px rgba(255,0,128,0.5);
        }
        
        .end-stats {
            background: rgba(0,0,0,0.3);
            border-radius: 10px;
            padding: 30px;
            margin: 20px auto;
            max-width: 600px;
        }
        
        .stat-item {
            display: flex;
            justify-content: space-between;
            padding: 10px 0;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        
        .restart-btn {
            background: linear-gradient(90deg, #00d4ff, #0066ff);
            color: #fff;
            border: none;
            border-radius: 10px;
            padding: 15px 60px;
            font-size: 1.2em;
            cursor: pointer;
            margin-top: 30px;
            transition: all 0.3s ease;
        }
        
        .restart-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 5px 20px rgba(0,212,255,0.4);
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- 开始界面 -->
        <div id="start-screen">
            <h1 class="title">网络安全棋谱对抗系统</h1>
            <p class="subtitle">多维度、多角色、智能化的网络攻防演练平台</p>
            
            <div class="role-selection">
                <div class="role-card" data-role="attacker">
                    <h3>🔴 攻击方</h3>
                    <p>扮演高级持续性威胁(APT)组织，利用各种攻击手段渗透目标系统。掌握0day漏洞库、计算资源和时间窗口。</p>
                </div>
                <div class="role-card" data-role="defender">
                    <h3>🔵 防守方</h3>
                    <p>负责保护关键信息基础设施，部署多层防御体系，管理安全预算和人力资源，快速响应各类威胁。</p>
                </div>
                <div class="role-card" data-role="monitor">
                    <h3>🟡 监管者</h3>
                    <p>第三方监管机构，追踪攻击源、收集证据、实施制裁。平衡攻防双方，维护网络空间秩序。</p>
                </div>
            </div>
            
            <button class="start-btn" id="startBtn" disabled>开始对抗</button>
        </div>
        
        <!-- 游戏主界面 -->
        <div id="game-screen">
            <div class="game-header">
                <div class="round-info">第 <span id="currentRound">1</span> / <span id="maxRound">15</span> 回合</div>
                <div class="resource-panel" id="resourcePanel">
                    <!-- 动态生成资源显示 -->
                </div>
            </div>
            
            <div class="battlefield-container">
                <!-- 左侧：多层次战场状态 -->
                <div class="battlefield-layers">
                    <div class="layer-title">🛡️ 系统防护状态</div>
                    <div id="layersStatus">
                        <!-- 动态生成层级状态 -->
                    </div>
                </div>
                
                <!-- 中间：战术选择 -->
                <div class="tactics-area">
                    <div class="tactics-title" id="tacticsTitle">选择战术</div>
                    <div class="tactics-grid" id="tacticsGrid">
                        <!-- 动态生成战术卡片 -->
                    </div>
                    <div class="action-buttons">
                        <button class="execute-btn" id="executeBtn">执行行动</button>
                    </div>
                </div>
                
                <!-- 右侧：情报面板 -->
                <div class="intel-panel">
                    <div class="intel-title">📡 情报信息</div>
                    <div id="intelList">
                        <!-- 动态生成情报 -->
                    </div>
                </div>
            </div>
            
            <!-- 操作日志 -->
            <div class="action-log">
                <div class="log-title">📜 行动日志</div>
                <div id="actionLog">
                    <!-- 动态生成日志 -->
                </div>
            </div>
        </div>
        
        <!-- 事件弹窗 -->
        <div class="event-modal" id="eventModal">
            <div class="event-content">
                <div class="event-title" id="eventTitle"></div>
                <div class="event-desc" id="eventDesc"></div>
                <div class="event-impact" id="eventImpact"></div>
                <button class="execute-btn" onclick="closeEventModal()">确认</button>
            </div>
        </div>
        
        <!-- 结束界面 -->
        <div id="end-screen">
            <h1 class="end-title" id="endTitle"></h1>
            <div class="end-stats" id="endStats">
                <!-- 动态生成统计数据 -->
            </div>
            <button class="restart-btn" onclick="location.reload()">重新开始</button>
        </div>
    </div>
    
    <script>
        // 游戏核心数据结构
        const GameState = {
            currentRole: null,
            currentRound: 1,
            maxRound: 15,
            
            // 多层次战场状态
            layers: {
                network: { name: '网络层', health: 100, maxHealth: 100, defense: 20 },
                application: { name: '应用层', health: 100, maxHealth: 100, defense: 15 },
                data: { name: '数据层', health: 100, maxHealth: 100, defense: 25 },
                physical: { name: '物理层', health: 100, maxHealth: 100, defense: 30 },
                personnel: { name: '人员层', health: 100, maxHealth: 100, defense: 10 }
            },
            
            // 资源管理
            resources: {
                attacker: {
                    compute: { name: '计算资源', value: 100, max: 100, icon: '💻' },
                    zeroday: { name: '0day库存', value: 5, max: 10, icon: '🔓' },
                    time: { name: '时间窗口', value: 50, max: 50, icon: '⏱️' }
                },
                defender: {
                    budget: { name: '安全预算', value: 1000, max: 1000, icon: '💰' },
                    manpower: { name: '人力资源', value: 20, max: 20, icon: '👥' },
                    repair: { name: '修复能力', value: 30, max: 30, icon: '🔧' }
                },
                monitor: {
                    investigation: { name: '调查资源', value: 50, max: 50, icon: '🔍' },
                    authority: { name: '执法权限', value: 30, max: 30, icon: '⚖️' },
                    intel: { name: '情报网络', value: 40, max: 40, icon: '📡' }
                }
            },
            
            // 情报系统
            intelligence: [],
            
            // 行动日志
            actionLog: [],
            
            // 当前选择的战术
            selectedTactic: null,
            
            // 连锁反应追踪
            chainEffects: [],
            
            // 动态事件队列
            eventQueue: []
        };
        
        // 战术定义
        const Tactics = {
            attacker: [
                {
                    id: 'apt_recon',
                    name: 'APT侦察',
                    cost: { compute: 10, time: 5 },
                    desc: '深度信息收集，发现薄弱点',
                    effect: (state) => {
                        state.intelligence.push({ 
                            type: 'recon',
                            content: '发现目标应用层存在潜在漏洞',
                            source: 'attacker'
                        });
                        return { success: true, message: '侦察完成，获得关键情报' };
                    }
                },
                {
                    id: 'zero_day',
                    name: '0day攻击',
                    cost: { zeroday: 1, compute: 30 },
                    desc: '使用未公开漏洞进行攻击',
                    effect: (state) => {
                        const damage = 40 + Math.random() * 20;
                        const targetLayer = 'application';
                        state.layers[targetLayer].health -= damage;
                        if (state.layers[targetLayer].health <= 30) {
                            state.chainEffects.push({ type: 'cascade', target: 'data' });
                        }
                        return { success: true, message: `0day攻击成功，造成${damage.toFixed(0)}点损害` };
                    }
                },
                {
                    id: 'ddos',
                    name: 'DDoS攻击',
                    cost: { compute: 50, time: 10 },
                    desc: '分布式拒绝服务攻击',
                    effect: (state) => {
                        state.layers.network.health -= 25;
                        state.resources.defender.manpower.value -= 5;
                        return { success: true, message: 'DDoS攻击消耗了防守方大量资源' };
                    }
                },
                {
                    id: 'social_eng',
                    name: '社会工程',
                    cost: { time: 15 },
                    desc: '针对人员层的心理攻击',
                    effect: (state) => {
                        if (Math.random() > 0.3) {
                            state.layers.personnel.health -= 35;
                            state.layers.application.defense -= 5;
                            return { success: true, message: '社工攻击成功，内部人员被策反' };
                        }
                        return { success: false, message: '社工攻击被识破' };
                    }
                },
                {
                    id: 'supply_chain',
                    name: '供应链攻击',
                    cost: { compute: 40, time: 20, zeroday: 1 },
                    desc: '通过供应链渗透目标',
                    effect: (state) => {
                        state.layers.physical.health -= 30;
                        state.layers.application.health -= 20;
                        state.chainEffects.push({ type: 'persistent', duration: 3 });
                        return { success: true, message: '供应链攻击建立持久化后门' };
                    }
                }
            ],
            defender: [
                {
                    id: 'patch_update',
                    name: '补丁更新',
                    cost: { budget: 100, manpower: 3 },
                    desc: '修复已知漏洞，提升防御',
                    effect: (state) => {
                        Object.keys(state.layers).forEach(layer => {
                            state.layers[layer].defense += 5;
                            state.layers[layer].health = Math.min(
                                state.layers[layer].health + 10,
                                state.layers[layer].maxHealth
                            );
                        });
                        return { success: true, message: '系统补丁更新完成' };
                    }
                },
                {
                    id: 'honeypot',
                    name: '蜜罐部署',
                    cost: { budget: 150, manpower: 5 },
                    desc: '部署欺骗防御系统',
                    effect: (state) => {
                        state.intelligence.push({
                            type: 'trap',
                            content: '蜜罐系统已激活，正在追踪攻击者',
                            source: 'defender'
                        });
                        state.resources.attacker.time.value -= 10;
                        return { success: true, message: '蜜罐成功误导攻击者' };
                    }
                },
                {
                    id: 'incident_response',
                    name: '应急响应',
                    cost: { manpower: 8, repair: 15 },
                    desc: '快速响应并修复损害',
                    effect: (state) => {
                        const mostDamaged = Object.keys(state.layers).reduce((a, b) => 
                            state.layers[a].health < state.layers[b].health ? a : b
                        );
                        state.layers[mostDamaged].health = Math.min(
                            state.layers[mostDamaged].health + 40,
                            state.layers[mostDamaged].maxHealth
                        );
                        return { success: true, message: `${state.layers[mostDamaged].name}已修复` };
                    }
                },
                {
                    id: 'threat_hunting',
                    name: '威胁狩猎',
                    cost: { manpower: 6, budget: 80 },
                    desc: '主动搜索潜在威胁',
                    effect: (state) => {
                        if (state.chainEffects.length > 0) {
                            state.chainEffects.pop();
                            state.intelligence.push({
                                type: 'detection',
                                content: '发现并清除了潜伏的威胁',
                                source: 'defender'
                            });
                            return { success: true, message: '成功清除潜伏威胁' };
                        }
                        return { success: false, message: '未发现异常活动' };
                    }
                },
                {
                    id: 'zero_trust',
                    name: '零信任架构',
                    cost: { budget: 300, manpower: 10 },
                    desc: '部署零信任安全架构',
                    effect: (state) => {
                        state.layers.network.defense += 15;
                        state.layers.application.defense += 15;
                        state.layers.data.defense += 20;
                        return { success: true, message: '零信任架构部署完成' };
                    }
                }
            ],
            monitor: [
                {
                    id: 'trace_source',
                    name: '溯源追踪',
                    cost: { investigation: 15, intel: 10 },
                    desc: '追踪攻击来源',
                    effect: (state) => {
                        state.intelligence.push({
                            type: 'trace',
                            content: '已定位攻击者IP段，准备制裁',
                            source: 'monitor'
                        });
                        state.resources.attacker.time.value -= 15;
                        return { success: true, message: '攻击源追踪成功' };
                    }
                },
                {
                    id: 'legal_sanction',
                    name: '法律制裁',
                    cost: { authority: 20, investigation: 20 },
                    desc: '对攻击者实施法律制裁',
                    effect: (state) => {
                        state.resources.attacker.compute.value -= 30;
                        state.resources.attacker.zeroday.value = Math.max(0, state.resources.attacker.zeroday.value - 1);
                        return { success: true, message: '制裁生效，攻击者资源受限' };
                    }
                },
                {
                    id: 'intel_sharing',
                    name: '情报共享',
                    cost: { intel: 15 },
                    desc: '向防守方提供威胁情报',
                    effect: (state) => {
                        state.intelligence.push({
                            type: 'shared',
                            content: '监管机构共享了最新威胁情报',
                            source: 'monitor'
                        });
                        state.resources.defender.manpower.value += 5;
                        Object.keys(state.layers).forEach(layer => {
                            state.layers[layer].defense += 3;
                        });
                        return { success: true, message: '情报共享增强了防御能力' };
                    }
                },
                {
                    id: 'emergency_takeover',
                    name: '紧急接管',
                    cost: { authority: 25, investigation: 25 },
                    desc: '紧急接管受损系统',
                    effect: (state) => {
                        const criticalLayers = Object.keys(state.layers).filter(
                            layer => state.layers[layer].health < 30
                        );
                        criticalLayers.forEach(layer => {
                            state.layers[layer].health = 50;
                            state.layers[layer].defense += 10;
                        });
                        return { 
                            success: true, 
                            message: criticalLayers.length > 0 ? '紧急接管并稳定了关键系统' : '系统状态良好，无需接管'
                        };
                    }
                },
                {
                    id: 'public_disclosure',
                    name: '公开披露',
                    cost: { intel: 20, authority: 10 },
                    desc: '公开攻击手法，警示他人',
                    effect: (state) => {
                        state.resources.attacker.zeroday.value = Math.max(0, state.resources.attacker.zeroday.value - 2);
                        state.intelligence.push({
                            type: 'disclosure',
                            content: '攻击手法已公开，0day价值降低',
                            source: 'monitor'
                        });
                        return { success: true, message: '公开披露削弱了攻击者优势' };
                    }
                }
            ]
        };
        
        // 动态事件定义
        const DynamicEvents = [
            {
                id: 'zero_day_leak',
                name: '0day泄露',
                probability: 0.1,
                condition: (state) => state.currentRound > 3,
                effect: (state) => {
                    state.resources.attacker.zeroday.value += 2;
                    return '地下市场出现新的0day漏洞交易';
                }
            },
            {
                id: 'emergency_patch',
                name: '紧急补丁',
                probability: 0.15,
                condition: (state) => Object.values(state.layers).some(l => l.health < 50),
                effect: (state) => {
                    Object.keys(state.layers).forEach(layer => {
                        state.layers[layer].defense += 8;
                    });
                    return '厂商发布紧急安全补丁';
                }
            },
            {
                id: 'insider_threat',
                name: '内部威胁',
                probability: 0.08,
                condition: (state) => state.layers.personnel.health < 70,
                effect: (state) => {
                    state.layers.data.health -= 20;
                    state.layers.application.defense -= 10;
                    return '发现内部人员泄露敏感信息';
                }
            },
            {
                id: 'regulatory_audit',
                name: '监管审计',
                probability: 0.12,
                condition: (state) => state.currentRound > 5,
                effect: (state) => {
                    state.resources.monitor.authority.value += 10;
                    state.resources.monitor.investigation.value += 15;
                    return '监管部门启动安全审计';
                }
            },
            {
                id: 'ddos_botnet',
                name: '僵尸网络激活',
                probability: 0.1,
                condition: (state) => state.resources.attacker.compute.value > 50,
                effect: (state) => {
                    state.layers.network.health -= 15;
                    state.resources.defender.manpower.value -= 3;
                    return '大规模僵尸网络被激活';
                }
            }
        ];
        
        // 游戏初始化
        function initGame() {
            // 角色选择事件
            document.querySelectorAll('.role-card').forEach(card => {
                card.addEventListener('click', function() {
                    document.querySelectorAll('.role-card').forEach(c => c.classList.remove('selected'));
                    this.classList.add('selected');
                    GameState.currentRole = this.dataset.role;
                    document.getElementById('startBtn').disabled = false;
                });
            });
            
            // 开始按钮事件
            document.getElementById('startBtn').addEventListener('click', startGame);
            
            // 执行按钮事件
            document.getElementById('executeBtn').addEventListener('click', executeTactic);
        }
        
        // 开始游戏
        function startGame() {
            document.getElementById('start-screen').style.display = 'none';
            document.getElementById('game-screen').style.display = 'block';
            
            updateResourcePanel();
            updateLayersStatus();
            generateTactics();
            addIntelligence('系统初始化完成，对抗开始', 'system');
            addActionLog('游戏开始 - 角色: ' + getRoleName(GameState.currentRole), 'system');
            
            // 启动AI对手
            if (GameState.currentRole !== 'attacker') {
                setTimeout(() => aiAction('attacker'), 2000);
            }
            if (GameState.currentRole !== 'defender') {
                setTimeout(() => aiAction('defender'), 3000);
            }
            if (GameState.currentRole !== 'monitor') {
                setTimeout(() => aiAction('monitor'), 4000);
            }
        }
        
        // 更新资源面板
        function updateResourcePanel() {
            const panel = document.getElementById('resourcePanel');
            const resources = GameState.resources[GameState.currentRole];
            
            panel.innerHTML = '';
            Object.keys(resources).forEach(key => {
                const resource = resources[key];
                panel.innerHTML += `
                    <div class="resource-item">
                        <div class="resource-icon">${resource.icon}</div>
                        <div>
                            <div style="font-size: 0.8em; color: #8b95a7;">${resource.name}</div>
                            <div class="resource-value">${resource.value} / ${resource.max}</div>
                        </div>
                    </div>
                `;
            });
        }
        
        // 更新层级状态
        function updateLayersStatus() {
            const container = document.getElementById('layersStatus');
            container.innerHTML = '';
            
            Object.keys(GameState.layers).forEach(key => {
                const layer = GameState.layers[key];
                const healthPercent = (layer.health / layer.maxHealth) * 100;
                let statusColor = '#00ff88';
                if (healthPercent < 30) statusColor = '#ff0080';
                else if (healthPercent < 60) statusColor = '#ffd700';
                
                container.innerHTML += `
                    <div class="layer-item">
                        <div class="layer-name">${layer.name}</div>
                        <div class="layer-status">
                            <div class="status-bar">
                                <div class="status-fill" style="width: ${healthPercent}%; background: ${statusColor};"></div>
                            </div>
                            <div class="status-value">${layer.health}/${layer.maxHealth}</div>
                        </div>
                    </div>
                `;
            });
        }
        
        // 生成战术选项
        function generateTactics() {
            const container = document.getElementById('tacticsGrid');
            const tactics = Tactics[GameState.currentRole];
            const resources = GameState.resources[GameState.currentRole];
            
            container.innerHTML = '';
            document.getElementById('tacticsTitle').textContent = `选择${getRoleName(GameState.currentRole)}战术`;
            
            tactics.forEach(tactic => {
                const canAfford = checkResourceCost(tactic.cost, resources);
                
                container.innerHTML += `
                    <div class="tactic-card ${!canAfford ? 'disabled' : ''}" 
                         data-id="${tactic.id}" 
                         onclick="selectTactic('${tactic.id}')">
                        <div class="tactic-name">${tactic.name}</div>
                        <div class="tactic-cost">消耗: ${formatCost(tactic.cost)}</div>
                        <div class="tactic-desc">${tactic.desc}</div>
                    </div>
                `;
            });
        }
        
        // 选择战术
        function selectTactic(tacticId) {
            const tactics = Tactics[GameState.currentRole];
            const tactic = tactics.find(t => t.id === tacticId);
            const resources = GameState.resources[GameState.currentRole];
            
            if (!checkResourceCost(tactic.cost, resources)) {
                showEventModal('资源不足', '当前资源无法支持此战术', '请选择其他战术或等待资源恢复');
                return;
            }
            
            document.querySelectorAll('.tactic-card').forEach(card => {
                card.classList.remove('selected');
            });
            
            document.querySelector(`[data-id="${tacticId}"]`).classList.add('selected');
            GameState.selectedTactic = tactic;
            document.getElementById('executeBtn').disabled = false;
        }
        
        // 执行战术
        function executeTactic() {
            if (!GameState.selectedTactic) return;
            
            const tactic = GameState.selectedTactic;
            const resources = GameState.resources[GameState.currentRole];
            
            // 扣除资源
            Object.keys(tactic.cost).forEach(key => {
                resources[key].value -= tactic.cost[key];
            });
            
            // 执行效果
            const result = tactic.effect(GameState);
            
            // 记录日志
            addActionLog(`${getRoleName(GameState.currentRole)}: ${tactic.name} - ${result.message}`, GameState.currentRole);
            
            // 处理连锁反应
            processChainEffects();
            
            // 检查动态事件
            checkDynamicEvents();
            
            // 更新界面
            updateResourcePanel();
            updateLayersStatus();
            generateTactics();
            
            // 清除选择
            GameState.selectedTactic = null;
            document.getElementById('executeBtn').disabled = true;
            
            // 下一回合
            nextRound();
        }
        
        // 处理连锁反应
        function processChainEffects() {
            GameState.chainEffects.forEach(effect => {
                if (effect.type === 'cascade' && effect.target) {
                    GameState.layers[effect.target].health -= 15;
                    addIntelligence(`连锁反应：${GameState.layers[effect.target].name}受到影响`, 'system');
                } else if (effect.type === 'persistent') {
                    Object.keys(GameState.layers).forEach(layer => {
                        GameState.layers[layer].health -= 5;
                    });
                    effect.duration--;
                    if (effect.duration <= 0) {
                        GameState.chainEffects = GameState.chainEffects.filter(e => e !== effect);
                    }
                }
            });
        }
        
        // 检查动态事件
        function checkDynamicEvents() {
            DynamicEvents.forEach(event => {
                if (Math.random() < event.probability && event.condition(GameState)) {
                    const message = event.effect(GameState);
                    showEventModal(event.name, message, '这将影响后续对抗局势');
                    addIntelligence(`事件: ${message}`, 'event');
                }
            });
        }
        
        // AI行动
        function aiAction(role) {
            if (GameState.currentRound > GameState.maxRound) return;
            if (role === GameState.currentRole) return;
            
            const tactics = Tactics[role];
            const resources = GameState.resources[role];
            
            // AI选择可用的战术
            const availableTactics = tactics.filter(t => checkResourceCost(t.cost, resources));
            if (availableTactics.length === 0) {
                addActionLog(`${getRoleName(role)}: 资源不足，跳过回合`, role);
                return;
            }
            
            // 随机选择一个战术
            const tactic = availableTactics[Math.floor(Math.random() * availableTactics.length)];
            
            // 执行战术
            Object.keys(tactic.cost).forEach(key => {
                resources[key].value -= tactic.cost[key];
            });
            
            const result = tactic.effect(GameState);
            addActionLog(`${getRoleName(role)}: ${tactic.name} - ${result.message}`, role);
            
            // 更新界面
            updateLayersStatus();
            
            // 继续AI行动
            setTimeout(() => aiAction(role), 5000 + Math.random() * 5000);
        }
        
        // 下一回合
        function nextRound() {
            GameState.currentRound++;
            document.getElementById('currentRound').textContent = GameState.currentRound;
            
            // 资源恢复
            Object.keys(GameState.resources).forEach(role => {
                const resources = GameState.resources[role];
                Object.keys(resources).forEach(key => {
                    resources[key].value = Math.min(
                        resources[key].value + Math.floor(resources[key].max * 0.1),
                        resources[key].max
                    );
                });
            });
            
            // 检查游戏结束条件
            if (checkGameEnd()) {
                endGame();
            }
        }
        
        // 检查游戏结束
        function checkGameEnd() {
            // 检查是否所有层级都被攻破
            const allLayersDown = Object.values(GameState.layers).every(layer => layer.health <= 0);
            if (allLayersDown) {
                GameState.winner = 'attacker';
                return true;
            }
            
            // 检查是否达到最大回合数
            if (GameState.currentRound >= GameState.maxRound) {
                const totalHealth = Object.values(GameState.layers).reduce((sum, layer) => sum + layer.health, 0);
                const maxTotalHealth = Object.values(GameState.layers).reduce((sum, layer) => sum + layer.maxHealth, 0);
                
                if (totalHealth > maxTotalHealth * 0.6) {
                    GameState.winner = 'defender';
                } else if (totalHealth > maxTotalHealth * 0.3) {
                    GameState.winner = 'monitor';
                } else {
                    GameState.winner = 'attacker';
                }
                return true;
            }
            
            return false;
        }
        
        // 游戏结束
        function endGame() {
            document.getElementById('game-screen').style.display = 'none';
            document.getElementById('end-screen').style.display = 'block';
            
            const endTitle = document.getElementById('endTitle');
            const isVictory = GameState.winner === GameState.currentRole;
            
            endTitle.className = 'end-title ' + (isVictory ? 'victory' : 'defeat');
            endTitle.textContent = isVictory ? '🎉 胜利！' : '💔 失败';
            
            // 统计数据
            const stats = document.getElementById('endStats');
            const totalDamage = Object.values(GameState.layers).reduce(
                (sum, layer) => sum + (layer.maxHealth - layer.health), 0
            );
            
            stats.innerHTML = `
                <div class="stat-item">
                    <span>对抗回合</span>
                    <span>${GameState.currentRound}</span>
                </div>
                <div class="stat-item">
                    <span>最终胜者</span>
                    <span>${getRoleName(GameState.winner)}</span>
                </div>
                <div class="stat-item">
                    <span>系统总损失</span>
                    <span>${totalDamage.toFixed(0)}</span>
                </div>
                <div class="stat-item">
                    <span>情报收集</span>
                    <span>${GameState.intelligence.length} 条</span>
                </div>
                <div class="stat-item">
                    <span>战术执行</span>
                    <span>${GameState.actionLog.filter(log => log.includes(GameState.currentRole)).length} 次</span>
                </div>
            `;
        }
        
        // 辅助函数
        function getRoleName(role) {
            const names = {
                attacker: '攻击方',
                defender: '防守方',
                monitor: '监管者'
            };
            return names[role] || role;
        }
        
        function checkResourceCost(cost, resources) {
            return Object.keys(cost).every(key => resources[key].value >= cost[key]);
        }
        
        function formatCost(cost) {
            return Object.keys(cost).map(key => `${cost[key]}${key}`).join(', ');
        }
        
        function addIntelligence(content, source) {
            const intelList = document.getElementById('intelList');
            const intel = document.createElement('div');
            intel.className = 'intel-item intel-new';
            intel.textContent = content;
            intelList.insertBefore(intel, intelList.firstChild);
            
            // 限制显示数量
            while (intelList.children.length > 5) {
                intelList.removeChild(intelList.lastChild);
            }
            
            GameState.intelligence.push({ content, source, round: GameState.currentRound });
            
            setTimeout(() => intel.classList.remove('intel-new'), 3000);
        }
        
        function addActionLog(message, type) {
            const logContainer = document.getElementById('actionLog');
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            entry.textContent = `[回合${GameState.currentRound}] ${message}`;
            logContainer.insertBefore(entry, logContainer.firstChild);
            
            // 限制日志数量
            while (logContainer.children.length > 20) {
                logContainer.removeChild(logContainer.lastChild);
            }
            
            GameState.actionLog.push({ message, type, round: GameState.currentRound });
        }
        
        function showEventModal(title, desc, impact) {
            const modal = document.getElementById('eventModal');
            document.getElementById('eventTitle').textContent = title;
            document.getElementById('eventDesc').textContent = desc;
            document.getElementById('eventImpact').textContent = impact;
            modal.style.display = 'flex';
        }
        
        function closeEventModal() {
            document.getElementById('eventModal').style.display = 'none';
        }
        
        // 初始化游戏
        initGame();
    </script>
</body>
</html>