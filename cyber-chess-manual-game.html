<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç½‘ç»œå®‰å…¨æ£‹è°± - å¤šç»´åº¦å¯¹æŠ—ç³»ç»Ÿ</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'å¾®è½¯é›…é»‘', Arial, sans-serif;
            background: linear-gradient(135deg, #0f1419 0%, #1a2332 100%);
            min-height: 100vh;
            color: #fff;
            overflow-x: hidden;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }
        
        /* å¼€å§‹ç•Œé¢ */
        #start-screen {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            text-align: center;
        }
        
        .title {
            font-size: 3em;
            font-weight: bold;
            margin-bottom: 20px;
            background: linear-gradient(90deg, #00d4ff, #ff0080);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 30px rgba(0,212,255,0.5);
        }
        
        .subtitle {
            font-size: 1.2em;
            color: #8b95a7;
            margin-bottom: 40px;
        }
        
        .role-selection {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 30px;
            margin-bottom: 40px;
        }
        
        .role-card {
            background: rgba(255,255,255,0.05);
            border: 2px solid rgba(255,255,255,0.1);
            border-radius: 15px;
            padding: 30px;
            cursor: pointer;
            transition: all 0.3s ease;
            width: 250px;
        }
        
        .role-card:hover {
            transform: translateY(-5px);
            border-color: rgba(0,212,255,0.5);
            background: rgba(0,212,255,0.1);
        }
        
        .role-card.selected {
            border-color: #00d4ff;
            background: rgba(0,212,255,0.2);
            box-shadow: 0 0 20px rgba(0,212,255,0.3);
        }
        
        .role-card h3 {
            font-size: 1.5em;
            margin-bottom: 15px;
        }
        
        .role-card p {
            color: #8b95a7;
            font-size: 0.9em;
            line-height: 1.5;
        }
        
        .start-btn {
            background: linear-gradient(90deg, #00d4ff, #0066ff);
            color: #fff;
            border: none;
            border-radius: 10px;
            padding: 15px 60px;
            font-size: 1.2em;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .start-btn:disabled {
            background: #444;
            cursor: not-allowed;
            opacity: 0.5;
        }
        
        .start-btn:not(:disabled):hover {
            transform: scale(1.05);
            box-shadow: 0 5px 20px rgba(0,212,255,0.4);
        }
        
        /* æ¸¸æˆä¸»ç•Œé¢ */
        #game-screen {
            display: none;
        }
        
        .game-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px;
            background: rgba(0,0,0,0.3);
            border-radius: 10px;
            margin-bottom: 20px;
        }
        
        .round-info {
            font-size: 1.3em;
            font-weight: bold;
        }
        
        .resource-panel {
            display: flex;
            gap: 30px;
        }
        
        .resource-item {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .resource-icon {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
        }
        
        .resource-value {
            font-size: 1.1em;
            font-weight: bold;
        }
        
        /* å¤šå±‚æ¬¡æˆ˜åœº */
        .battlefield-container {
            display: grid;
            grid-template-columns: 1fr 2fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .battlefield-layers {
            background: rgba(0,0,0,0.3);
            border-radius: 10px;
            padding: 20px;
        }
        
        .layer-title {
            font-size: 1.1em;
            font-weight: bold;
            margin-bottom: 15px;
            color: #00d4ff;
        }
        
        .layer-item {
            background: rgba(255,255,255,0.05);
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .layer-name {
            font-weight: bold;
        }
        
        .layer-status {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .status-bar {
            width: 100px;
            height: 8px;
            background: rgba(255,255,255,0.1);
            border-radius: 4px;
            overflow: hidden;
        }
        
        .status-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff0080, #00d4ff);
            transition: width 0.3s ease;
        }
        
        .status-value {
            font-size: 0.9em;
            color: #8b95a7;
        }
        
        /* æˆ˜æœ¯é€‰æ‹©åŒº */
        .tactics-area {
            background: rgba(0,0,0,0.3);
            border-radius: 10px;
            padding: 20px;
        }
        
        .tactics-title {
            font-size: 1.2em;
            font-weight: bold;
            margin-bottom: 15px;
            text-align: center;
        }
        
        .tactics-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
        }
        
        .tactic-card {
            background: rgba(255,255,255,0.05);
            border: 2px solid rgba(255,255,255,0.1);
            border-radius: 8px;
            padding: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .tactic-card:hover {
            border-color: rgba(0,212,255,0.5);
            background: rgba(0,212,255,0.1);
        }
        
        .tactic-card.selected {
            border-color: #00d4ff;
            background: rgba(0,212,255,0.2);
        }
        
        .tactic-card.disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .tactic-name {
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .tactic-cost {
            font-size: 0.8em;
            color: #ff9800;
        }
        
        .tactic-desc {
            font-size: 0.8em;
            color: #8b95a7;
            margin-top: 5px;
        }
        
        /* æƒ…æŠ¥é¢æ¿ */
        .intel-panel {
            background: rgba(0,0,0,0.3);
            border-radius: 10px;
            padding: 20px;
        }
        
        .intel-title {
            font-size: 1.1em;
            font-weight: bold;
            margin-bottom: 15px;
            color: #ffd700;
        }
        
        .intel-item {
            background: rgba(255,215,0,0.1);
            border-left: 3px solid #ffd700;
            padding: 10px;
            margin-bottom: 10px;
            font-size: 0.9em;
        }
        
        .intel-new {
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% { background: rgba(255,215,0,0.1); }
            50% { background: rgba(255,215,0,0.2); }
            100% { background: rgba(255,215,0,0.1); }
        }
        
        /* æ“ä½œæ—¥å¿— */
        .action-log {
            background: rgba(0,0,0,0.3);
            border-radius: 10px;
            padding: 20px;
            height: 300px;
            overflow-y: auto;
        }
        
        .log-title {
            font-size: 1.1em;
            font-weight: bold;
            margin-bottom: 15px;
            color: #00ff88;
        }
        
        .log-entry {
            padding: 8px;
            margin-bottom: 5px;
            border-left: 3px solid #00ff88;
            background: rgba(0,255,136,0.05);
            font-size: 0.9em;
        }
        
        .log-entry.attack {
            border-color: #ff0080;
            background: rgba(255,0,128,0.05);
        }
        
        .log-entry.defense {
            border-color: #00d4ff;
            background: rgba(0,212,255,0.05);
        }
        
        .log-entry.monitor {
            border-color: #ffd700;
            background: rgba(255,215,0,0.05);
        }
        
        /* æ‰§è¡ŒæŒ‰é’® */
        .action-buttons {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 20px;
        }
        
        .execute-btn {
            background: linear-gradient(90deg, #00ff88, #00d4ff);
            color: #000;
            border: none;
            border-radius: 8px;
            padding: 12px 40px;
            font-size: 1.1em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .execute-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 5px 20px rgba(0,255,136,0.4);
        }
        
        .execute-btn:disabled {
            background: #444;
            cursor: not-allowed;
            opacity: 0.5;
        }
        
        /* äº‹ä»¶å¼¹çª— */
        .event-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }
        
        .event-content {
            background: linear-gradient(135deg, #1a2332, #2a3442);
            border: 2px solid #00d4ff;
            border-radius: 15px;
            padding: 30px;
            max-width: 500px;
            text-align: center;
        }
        
        .event-title {
            font-size: 1.5em;
            font-weight: bold;
            margin-bottom: 15px;
            color: #ffd700;
        }
        
        .event-desc {
            margin-bottom: 20px;
            line-height: 1.5;
        }
        
        .event-impact {
            background: rgba(255,0,0,0.1);
            border: 1px solid rgba(255,0,0,0.3);
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 20px;
            color: #ff9800;
        }
        
        /* ç»“æŸç•Œé¢ */
        #end-screen {
            display: none;
            text-align: center;
            padding: 40px;
        }
        
        .end-title {
            font-size: 2.5em;
            font-weight: bold;
            margin-bottom: 20px;
        }
        
        .victory {
            color: #00ff88;
            text-shadow: 0 0 20px rgba(0,255,136,0.5);
        }
        
        .defeat {
            color: #ff0080;
            text-shadow: 0 0 20px rgba(255,0,128,0.5);
        }
        
        .end-stats {
            background: rgba(0,0,0,0.3);
            border-radius: 10px;
            padding: 30px;
            margin: 20px auto;
            max-width: 600px;
        }
        
        .stat-item {
            display: flex;
            justify-content: space-between;
            padding: 10px 0;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        
        .restart-btn {
            background: linear-gradient(90deg, #00d4ff, #0066ff);
            color: #fff;
            border: none;
            border-radius: 10px;
            padding: 15px 60px;
            font-size: 1.2em;
            cursor: pointer;
            margin-top: 30px;
            transition: all 0.3s ease;
        }
        
        .restart-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 5px 20px rgba(0,212,255,0.4);
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- å¼€å§‹ç•Œé¢ -->
        <div id="start-screen">
            <h1 class="title">ç½‘ç»œå®‰å…¨æ£‹è°±å¯¹æŠ—ç³»ç»Ÿ</h1>
            <p class="subtitle">å¤šç»´åº¦ã€å¤šè§’è‰²ã€æ™ºèƒ½åŒ–çš„ç½‘ç»œæ”»é˜²æ¼”ç»ƒå¹³å°</p>
            
            <div class="role-selection">
                <div class="role-card" data-role="attacker">
                    <h3>ğŸ”´ æ”»å‡»æ–¹</h3>
                    <p>æ‰®æ¼”é«˜çº§æŒç»­æ€§å¨èƒ(APT)ç»„ç»‡ï¼Œåˆ©ç”¨å„ç§æ”»å‡»æ‰‹æ®µæ¸—é€ç›®æ ‡ç³»ç»Ÿã€‚æŒæ¡0dayæ¼æ´åº“ã€è®¡ç®—èµ„æºå’Œæ—¶é—´çª—å£ã€‚</p>
                </div>
                <div class="role-card" data-role="defender">
                    <h3>ğŸ”µ é˜²å®ˆæ–¹</h3>
                    <p>è´Ÿè´£ä¿æŠ¤å…³é”®ä¿¡æ¯åŸºç¡€è®¾æ–½ï¼Œéƒ¨ç½²å¤šå±‚é˜²å¾¡ä½“ç³»ï¼Œç®¡ç†å®‰å…¨é¢„ç®—å’ŒäººåŠ›èµ„æºï¼Œå¿«é€Ÿå“åº”å„ç±»å¨èƒã€‚</p>
                </div>
                <div class="role-card" data-role="monitor">
                    <h3>ğŸŸ¡ ç›‘ç®¡è€…</h3>
                    <p>ç¬¬ä¸‰æ–¹ç›‘ç®¡æœºæ„ï¼Œè¿½è¸ªæ”»å‡»æºã€æ”¶é›†è¯æ®ã€å®æ–½åˆ¶è£ã€‚å¹³è¡¡æ”»é˜²åŒæ–¹ï¼Œç»´æŠ¤ç½‘ç»œç©ºé—´ç§©åºã€‚</p>
                </div>
            </div>
            
            <button class="start-btn" id="startBtn" disabled>å¼€å§‹å¯¹æŠ—</button>
        </div>
        
        <!-- æ¸¸æˆä¸»ç•Œé¢ -->
        <div id="game-screen">
            <div class="game-header">
                <div class="round-info">ç¬¬ <span id="currentRound">1</span> / <span id="maxRound">15</span> å›åˆ</div>
                <div class="resource-panel" id="resourcePanel">
                    <!-- åŠ¨æ€ç”Ÿæˆèµ„æºæ˜¾ç¤º -->
                </div>
            </div>
            
            <div class="battlefield-container">
                <!-- å·¦ä¾§ï¼šå¤šå±‚æ¬¡æˆ˜åœºçŠ¶æ€ -->
                <div class="battlefield-layers">
                    <div class="layer-title">ğŸ›¡ï¸ ç³»ç»Ÿé˜²æŠ¤çŠ¶æ€</div>
                    <div id="layersStatus">
                        <!-- åŠ¨æ€ç”Ÿæˆå±‚çº§çŠ¶æ€ -->
                    </div>
                </div>
                
                <!-- ä¸­é—´ï¼šæˆ˜æœ¯é€‰æ‹© -->
                <div class="tactics-area">
                    <div class="tactics-title" id="tacticsTitle">é€‰æ‹©æˆ˜æœ¯</div>
                    <div class="tactics-grid" id="tacticsGrid">
                        <!-- åŠ¨æ€ç”Ÿæˆæˆ˜æœ¯å¡ç‰‡ -->
                    </div>
                    <div class="action-buttons">
                        <button class="execute-btn" id="executeBtn">æ‰§è¡Œè¡ŒåŠ¨</button>
                    </div>
                </div>
                
                <!-- å³ä¾§ï¼šæƒ…æŠ¥é¢æ¿ -->
                <div class="intel-panel">
                    <div class="intel-title">ğŸ“¡ æƒ…æŠ¥ä¿¡æ¯</div>
                    <div id="intelList">
                        <!-- åŠ¨æ€ç”Ÿæˆæƒ…æŠ¥ -->
                    </div>
                </div>
            </div>
            
            <!-- æ“ä½œæ—¥å¿— -->
            <div class="action-log">
                <div class="log-title">ğŸ“œ è¡ŒåŠ¨æ—¥å¿—</div>
                <div id="actionLog">
                    <!-- åŠ¨æ€ç”Ÿæˆæ—¥å¿— -->
                </div>
            </div>
        </div>
        
        <!-- äº‹ä»¶å¼¹çª— -->
        <div class="event-modal" id="eventModal">
            <div class="event-content">
                <div class="event-title" id="eventTitle"></div>
                <div class="event-desc" id="eventDesc"></div>
                <div class="event-impact" id="eventImpact"></div>
                <button class="execute-btn" onclick="closeEventModal()">ç¡®è®¤</button>
            </div>
        </div>
        
        <!-- ç»“æŸç•Œé¢ -->
        <div id="end-screen">
            <h1 class="end-title" id="endTitle"></h1>
            <div class="end-stats" id="endStats">
                <!-- åŠ¨æ€ç”Ÿæˆç»Ÿè®¡æ•°æ® -->
            </div>
            <button class="restart-btn" onclick="location.reload()">é‡æ–°å¼€å§‹</button>
        </div>
    </div>
    
    <script>
        // æ¸¸æˆæ ¸å¿ƒæ•°æ®ç»“æ„
        const GameState = {
            currentRole: null,
            currentRound: 1,
            maxRound: 15,
            
            // å¤šå±‚æ¬¡æˆ˜åœºçŠ¶æ€
            layers: {
                network: { name: 'ç½‘ç»œå±‚', health: 100, maxHealth: 100, defense: 20 },
                application: { name: 'åº”ç”¨å±‚', health: 100, maxHealth: 100, defense: 15 },
                data: { name: 'æ•°æ®å±‚', health: 100, maxHealth: 100, defense: 25 },
                physical: { name: 'ç‰©ç†å±‚', health: 100, maxHealth: 100, defense: 30 },
                personnel: { name: 'äººå‘˜å±‚', health: 100, maxHealth: 100, defense: 10 }
            },
            
            // èµ„æºç®¡ç†
            resources: {
                attacker: {
                    compute: { name: 'è®¡ç®—èµ„æº', value: 100, max: 100, icon: 'ğŸ’»' },
                    zeroday: { name: '0dayåº“å­˜', value: 5, max: 10, icon: 'ğŸ”“' },
                    time: { name: 'æ—¶é—´çª—å£', value: 50, max: 50, icon: 'â±ï¸' }
                },
                defender: {
                    budget: { name: 'å®‰å…¨é¢„ç®—', value: 1000, max: 1000, icon: 'ğŸ’°' },
                    manpower: { name: 'äººåŠ›èµ„æº', value: 20, max: 20, icon: 'ğŸ‘¥' },
                    repair: { name: 'ä¿®å¤èƒ½åŠ›', value: 30, max: 30, icon: 'ğŸ”§' }
                },
                monitor: {
                    investigation: { name: 'è°ƒæŸ¥èµ„æº', value: 50, max: 50, icon: 'ğŸ”' },
                    authority: { name: 'æ‰§æ³•æƒé™', value: 30, max: 30, icon: 'âš–ï¸' },
                    intel: { name: 'æƒ…æŠ¥ç½‘ç»œ', value: 40, max: 40, icon: 'ğŸ“¡' }
                }
            },
            
            // æƒ…æŠ¥ç³»ç»Ÿ
            intelligence: [],
            
            // è¡ŒåŠ¨æ—¥å¿—
            actionLog: [],
            
            // å½“å‰é€‰æ‹©çš„æˆ˜æœ¯
            selectedTactic: null,
            
            // è¿é”ååº”è¿½è¸ª
            chainEffects: [],
            
            // åŠ¨æ€äº‹ä»¶é˜Ÿåˆ—
            eventQueue: []
        };
        
        // æˆ˜æœ¯å®šä¹‰
        const Tactics = {
            attacker: [
                {
                    id: 'apt_recon',
                    name: 'APTä¾¦å¯Ÿ',
                    cost: { compute: 10, time: 5 },
                    desc: 'æ·±åº¦ä¿¡æ¯æ”¶é›†ï¼Œå‘ç°è–„å¼±ç‚¹',
                    effect: (state) => {
                        state.intelligence.push({ 
                            type: 'recon',
                            content: 'å‘ç°ç›®æ ‡åº”ç”¨å±‚å­˜åœ¨æ½œåœ¨æ¼æ´',
                            source: 'attacker'
                        });
                        return { success: true, message: 'ä¾¦å¯Ÿå®Œæˆï¼Œè·å¾—å…³é”®æƒ…æŠ¥' };
                    }
                },
                {
                    id: 'zero_day',
                    name: '0dayæ”»å‡»',
                    cost: { zeroday: 1, compute: 30 },
                    desc: 'ä½¿ç”¨æœªå…¬å¼€æ¼æ´è¿›è¡Œæ”»å‡»',
                    effect: (state) => {
                        const damage = 40 + Math.random() * 20;
                        const targetLayer = 'application';
                        state.layers[targetLayer].health -= damage;
                        if (state.layers[targetLayer].health <= 30) {
                            state.chainEffects.push({ type: 'cascade', target: 'data' });
                        }
                        return { success: true, message: `0dayæ”»å‡»æˆåŠŸï¼Œé€ æˆ${damage.toFixed(0)}ç‚¹æŸå®³` };
                    }
                },
                {
                    id: 'ddos',
                    name: 'DDoSæ”»å‡»',
                    cost: { compute: 50, time: 10 },
                    desc: 'åˆ†å¸ƒå¼æ‹’ç»æœåŠ¡æ”»å‡»',
                    effect: (state) => {
                        state.layers.network.health -= 25;
                        state.resources.defender.manpower.value -= 5;
                        return { success: true, message: 'DDoSæ”»å‡»æ¶ˆè€—äº†é˜²å®ˆæ–¹å¤§é‡èµ„æº' };
                    }
                },
                {
                    id: 'social_eng',
                    name: 'ç¤¾ä¼šå·¥ç¨‹',
                    cost: { time: 15 },
                    desc: 'é’ˆå¯¹äººå‘˜å±‚çš„å¿ƒç†æ”»å‡»',
                    effect: (state) => {
                        if (Math.random() > 0.3) {
                            state.layers.personnel.health -= 35;
                            state.layers.application.defense -= 5;
                            return { success: true, message: 'ç¤¾å·¥æ”»å‡»æˆåŠŸï¼Œå†…éƒ¨äººå‘˜è¢«ç­–å' };
                        }
                        return { success: false, message: 'ç¤¾å·¥æ”»å‡»è¢«è¯†ç ´' };
                    }
                },
                {
                    id: 'supply_chain',
                    name: 'ä¾›åº”é“¾æ”»å‡»',
                    cost: { compute: 40, time: 20, zeroday: 1 },
                    desc: 'é€šè¿‡ä¾›åº”é“¾æ¸—é€ç›®æ ‡',
                    effect: (state) => {
                        state.layers.physical.health -= 30;
                        state.layers.application.health -= 20;
                        state.chainEffects.push({ type: 'persistent', duration: 3 });
                        return { success: true, message: 'ä¾›åº”é“¾æ”»å‡»å»ºç«‹æŒä¹…åŒ–åé—¨' };
                    }
                }
            ],
            defender: [
                {
                    id: 'patch_update',
                    name: 'è¡¥ä¸æ›´æ–°',
                    cost: { budget: 100, manpower: 3 },
                    desc: 'ä¿®å¤å·²çŸ¥æ¼æ´ï¼Œæå‡é˜²å¾¡',
                    effect: (state) => {
                        Object.keys(state.layers).forEach(layer => {
                            state.layers[layer].defense += 5;
                            state.layers[layer].health = Math.min(
                                state.layers[layer].health + 10,
                                state.layers[layer].maxHealth
                            );
                        });
                        return { success: true, message: 'ç³»ç»Ÿè¡¥ä¸æ›´æ–°å®Œæˆ' };
                    }
                },
                {
                    id: 'honeypot',
                    name: 'èœœç½éƒ¨ç½²',
                    cost: { budget: 150, manpower: 5 },
                    desc: 'éƒ¨ç½²æ¬ºéª—é˜²å¾¡ç³»ç»Ÿ',
                    effect: (state) => {
                        state.intelligence.push({
                            type: 'trap',
                            content: 'èœœç½ç³»ç»Ÿå·²æ¿€æ´»ï¼Œæ­£åœ¨è¿½è¸ªæ”»å‡»è€…',
                            source: 'defender'
                        });
                        state.resources.attacker.time.value -= 10;
                        return { success: true, message: 'èœœç½æˆåŠŸè¯¯å¯¼æ”»å‡»è€…' };
                    }
                },
                {
                    id: 'incident_response',
                    name: 'åº”æ€¥å“åº”',
                    cost: { manpower: 8, repair: 15 },
                    desc: 'å¿«é€Ÿå“åº”å¹¶ä¿®å¤æŸå®³',
                    effect: (state) => {
                        const mostDamaged = Object.keys(state.layers).reduce((a, b) => 
                            state.layers[a].health < state.layers[b].health ? a : b
                        );
                        state.layers[mostDamaged].health = Math.min(
                            state.layers[mostDamaged].health + 40,
                            state.layers[mostDamaged].maxHealth
                        );
                        return { success: true, message: `${state.layers[mostDamaged].name}å·²ä¿®å¤` };
                    }
                },
                {
                    id: 'threat_hunting',
                    name: 'å¨èƒç‹©çŒ',
                    cost: { manpower: 6, budget: 80 },
                    desc: 'ä¸»åŠ¨æœç´¢æ½œåœ¨å¨èƒ',
                    effect: (state) => {
                        if (state.chainEffects.length > 0) {
                            state.chainEffects.pop();
                            state.intelligence.push({
                                type: 'detection',
                                content: 'å‘ç°å¹¶æ¸…é™¤äº†æ½œä¼çš„å¨èƒ',
                                source: 'defender'
                            });
                            return { success: true, message: 'æˆåŠŸæ¸…é™¤æ½œä¼å¨èƒ' };
                        }
                        return { success: false, message: 'æœªå‘ç°å¼‚å¸¸æ´»åŠ¨' };
                    }
                },
                {
                    id: 'zero_trust',
                    name: 'é›¶ä¿¡ä»»æ¶æ„',
                    cost: { budget: 300, manpower: 10 },
                    desc: 'éƒ¨ç½²é›¶ä¿¡ä»»å®‰å…¨æ¶æ„',
                    effect: (state) => {
                        state.layers.network.defense += 15;
                        state.layers.application.defense += 15;
                        state.layers.data.defense += 20;
                        return { success: true, message: 'é›¶ä¿¡ä»»æ¶æ„éƒ¨ç½²å®Œæˆ' };
                    }
                }
            ],
            monitor: [
                {
                    id: 'trace_source',
                    name: 'æº¯æºè¿½è¸ª',
                    cost: { investigation: 15, intel: 10 },
                    desc: 'è¿½è¸ªæ”»å‡»æ¥æº',
                    effect: (state) => {
                        state.intelligence.push({
                            type: 'trace',
                            content: 'å·²å®šä½æ”»å‡»è€…IPæ®µï¼Œå‡†å¤‡åˆ¶è£',
                            source: 'monitor'
                        });
                        state.resources.attacker.time.value -= 15;
                        return { success: true, message: 'æ”»å‡»æºè¿½è¸ªæˆåŠŸ' };
                    }
                },
                {
                    id: 'legal_sanction',
                    name: 'æ³•å¾‹åˆ¶è£',
                    cost: { authority: 20, investigation: 20 },
                    desc: 'å¯¹æ”»å‡»è€…å®æ–½æ³•å¾‹åˆ¶è£',
                    effect: (state) => {
                        state.resources.attacker.compute.value -= 30;
                        state.resources.attacker.zeroday.value = Math.max(0, state.resources.attacker.zeroday.value - 1);
                        return { success: true, message: 'åˆ¶è£ç”Ÿæ•ˆï¼Œæ”»å‡»è€…èµ„æºå—é™' };
                    }
                },
                {
                    id: 'intel_sharing',
                    name: 'æƒ…æŠ¥å…±äº«',
                    cost: { intel: 15 },
                    desc: 'å‘é˜²å®ˆæ–¹æä¾›å¨èƒæƒ…æŠ¥',
                    effect: (state) => {
                        state.intelligence.push({
                            type: 'shared',
                            content: 'ç›‘ç®¡æœºæ„å…±äº«äº†æœ€æ–°å¨èƒæƒ…æŠ¥',
                            source: 'monitor'
                        });
                        state.resources.defender.manpower.value += 5;
                        Object.keys(state.layers).forEach(layer => {
                            state.layers[layer].defense += 3;
                        });
                        return { success: true, message: 'æƒ…æŠ¥å…±äº«å¢å¼ºäº†é˜²å¾¡èƒ½åŠ›' };
                    }
                },
                {
                    id: 'emergency_takeover',
                    name: 'ç´§æ€¥æ¥ç®¡',
                    cost: { authority: 25, investigation: 25 },
                    desc: 'ç´§æ€¥æ¥ç®¡å—æŸç³»ç»Ÿ',
                    effect: (state) => {
                        const criticalLayers = Object.keys(state.layers).filter(
                            layer => state.layers[layer].health < 30
                        );
                        criticalLayers.forEach(layer => {
                            state.layers[layer].health = 50;
                            state.layers[layer].defense += 10;
                        });
                        return { 
                            success: true, 
                            message: criticalLayers.length > 0 ? 'ç´§æ€¥æ¥ç®¡å¹¶ç¨³å®šäº†å…³é”®ç³»ç»Ÿ' : 'ç³»ç»ŸçŠ¶æ€è‰¯å¥½ï¼Œæ— éœ€æ¥ç®¡'
                        };
                    }
                },
                {
                    id: 'public_disclosure',
                    name: 'å…¬å¼€æŠ«éœ²',
                    cost: { intel: 20, authority: 10 },
                    desc: 'å…¬å¼€æ”»å‡»æ‰‹æ³•ï¼Œè­¦ç¤ºä»–äºº',
                    effect: (state) => {
                        state.resources.attacker.zeroday.value = Math.max(0, state.resources.attacker.zeroday.value - 2);
                        state.intelligence.push({
                            type: 'disclosure',
                            content: 'æ”»å‡»æ‰‹æ³•å·²å…¬å¼€ï¼Œ0dayä»·å€¼é™ä½',
                            source: 'monitor'
                        });
                        return { success: true, message: 'å…¬å¼€æŠ«éœ²å‰Šå¼±äº†æ”»å‡»è€…ä¼˜åŠ¿' };
                    }
                }
            ]
        };
        
        // åŠ¨æ€äº‹ä»¶å®šä¹‰
        const DynamicEvents = [
            {
                id: 'zero_day_leak',
                name: '0dayæ³„éœ²',
                probability: 0.1,
                condition: (state) => state.currentRound > 3,
                effect: (state) => {
                    state.resources.attacker.zeroday.value += 2;
                    return 'åœ°ä¸‹å¸‚åœºå‡ºç°æ–°çš„0dayæ¼æ´äº¤æ˜“';
                }
            },
            {
                id: 'emergency_patch',
                name: 'ç´§æ€¥è¡¥ä¸',
                probability: 0.15,
                condition: (state) => Object.values(state.layers).some(l => l.health < 50),
                effect: (state) => {
                    Object.keys(state.layers).forEach(layer => {
                        state.layers[layer].defense += 8;
                    });
                    return 'å‚å•†å‘å¸ƒç´§æ€¥å®‰å…¨è¡¥ä¸';
                }
            },
            {
                id: 'insider_threat',
                name: 'å†…éƒ¨å¨èƒ',
                probability: 0.08,
                condition: (state) => state.layers.personnel.health < 70,
                effect: (state) => {
                    state.layers.data.health -= 20;
                    state.layers.application.defense -= 10;
                    return 'å‘ç°å†…éƒ¨äººå‘˜æ³„éœ²æ•æ„Ÿä¿¡æ¯';
                }
            },
            {
                id: 'regulatory_audit',
                name: 'ç›‘ç®¡å®¡è®¡',
                probability: 0.12,
                condition: (state) => state.currentRound > 5,
                effect: (state) => {
                    state.resources.monitor.authority.value += 10;
                    state.resources.monitor.investigation.value += 15;
                    return 'ç›‘ç®¡éƒ¨é—¨å¯åŠ¨å®‰å…¨å®¡è®¡';
                }
            },
            {
                id: 'ddos_botnet',
                name: 'åƒµå°¸ç½‘ç»œæ¿€æ´»',
                probability: 0.1,
                condition: (state) => state.resources.attacker.compute.value > 50,
                effect: (state) => {
                    state.layers.network.health -= 15;
                    state.resources.defender.manpower.value -= 3;
                    return 'å¤§è§„æ¨¡åƒµå°¸ç½‘ç»œè¢«æ¿€æ´»';
                }
            }
        ];
        
        // æ¸¸æˆåˆå§‹åŒ–
        function initGame() {
            // è§’è‰²é€‰æ‹©äº‹ä»¶
            document.querySelectorAll('.role-card').forEach(card => {
                card.addEventListener('click', function() {
                    document.querySelectorAll('.role-card').forEach(c => c.classList.remove('selected'));
                    this.classList.add('selected');
                    GameState.currentRole = this.dataset.role;
                    document.getElementById('startBtn').disabled = false;
                });
            });
            
            // å¼€å§‹æŒ‰é’®äº‹ä»¶
            document.getElementById('startBtn').addEventListener('click', startGame);
            
            // æ‰§è¡ŒæŒ‰é’®äº‹ä»¶
            document.getElementById('executeBtn').addEventListener('click', executeTactic);
        }
        
        // å¼€å§‹æ¸¸æˆ
        function startGame() {
            document.getElementById('start-screen').style.display = 'none';
            document.getElementById('game-screen').style.display = 'block';
            
            updateResourcePanel();
            updateLayersStatus();
            generateTactics();
            addIntelligence('ç³»ç»Ÿåˆå§‹åŒ–å®Œæˆï¼Œå¯¹æŠ—å¼€å§‹', 'system');
            addActionLog('æ¸¸æˆå¼€å§‹ - è§’è‰²: ' + getRoleName(GameState.currentRole), 'system');
            
            // å¯åŠ¨AIå¯¹æ‰‹
            if (GameState.currentRole !== 'attacker') {
                setTimeout(() => aiAction('attacker'), 2000);
            }
            if (GameState.currentRole !== 'defender') {
                setTimeout(() => aiAction('defender'), 3000);
            }
            if (GameState.currentRole !== 'monitor') {
                setTimeout(() => aiAction('monitor'), 4000);
            }
        }
        
        // æ›´æ–°èµ„æºé¢æ¿
        function updateResourcePanel() {
            const panel = document.getElementById('resourcePanel');
            const resources = GameState.resources[GameState.currentRole];
            
            panel.innerHTML = '';
            Object.keys(resources).forEach(key => {
                const resource = resources[key];
                panel.innerHTML += `
                    <div class="resource-item">
                        <div class="resource-icon">${resource.icon}</div>
                        <div>
                            <div style="font-size: 0.8em; color: #8b95a7;">${resource.name}</div>
                            <div class="resource-value">${resource.value} / ${resource.max}</div>
                        </div>
                    </div>
                `;
            });
        }
        
        // æ›´æ–°å±‚çº§çŠ¶æ€
        function updateLayersStatus() {
            const container = document.getElementById('layersStatus');
            container.innerHTML = '';
            
            Object.keys(GameState.layers).forEach(key => {
                const layer = GameState.layers[key];
                const healthPercent = (layer.health / layer.maxHealth) * 100;
                let statusColor = '#00ff88';
                if (healthPercent < 30) statusColor = '#ff0080';
                else if (healthPercent < 60) statusColor = '#ffd700';
                
                container.innerHTML += `
                    <div class="layer-item">
                        <div class="layer-name">${layer.name}</div>
                        <div class="layer-status">
                            <div class="status-bar">
                                <div class="status-fill" style="width: ${healthPercent}%; background: ${statusColor};"></div>
                            </div>
                            <div class="status-value">${layer.health}/${layer.maxHealth}</div>
                        </div>
                    </div>
                `;
            });
        }
        
        // ç”Ÿæˆæˆ˜æœ¯é€‰é¡¹
        function generateTactics() {
            const container = document.getElementById('tacticsGrid');
            const tactics = Tactics[GameState.currentRole];
            const resources = GameState.resources[GameState.currentRole];
            
            container.innerHTML = '';
            document.getElementById('tacticsTitle').textContent = `é€‰æ‹©${getRoleName(GameState.currentRole)}æˆ˜æœ¯`;
            
            tactics.forEach(tactic => {
                const canAfford = checkResourceCost(tactic.cost, resources);
                
                container.innerHTML += `
                    <div class="tactic-card ${!canAfford ? 'disabled' : ''}" 
                         data-id="${tactic.id}" 
                         onclick="selectTactic('${tactic.id}')">
                        <div class="tactic-name">${tactic.name}</div>
                        <div class="tactic-cost">æ¶ˆè€—: ${formatCost(tactic.cost)}</div>
                        <div class="tactic-desc">${tactic.desc}</div>
                    </div>
                `;
            });
        }
        
        // é€‰æ‹©æˆ˜æœ¯
        function selectTactic(tacticId) {
            const tactics = Tactics[GameState.currentRole];
            const tactic = tactics.find(t => t.id === tacticId);
            const resources = GameState.resources[GameState.currentRole];
            
            if (!checkResourceCost(tactic.cost, resources)) {
                showEventModal('èµ„æºä¸è¶³', 'å½“å‰èµ„æºæ— æ³•æ”¯æŒæ­¤æˆ˜æœ¯', 'è¯·é€‰æ‹©å…¶ä»–æˆ˜æœ¯æˆ–ç­‰å¾…èµ„æºæ¢å¤');
                return;
            }
            
            document.querySelectorAll('.tactic-card').forEach(card => {
                card.classList.remove('selected');
            });
            
            document.querySelector(`[data-id="${tacticId}"]`).classList.add('selected');
            GameState.selectedTactic = tactic;
            document.getElementById('executeBtn').disabled = false;
        }
        
        // æ‰§è¡Œæˆ˜æœ¯
        function executeTactic() {
            if (!GameState.selectedTactic) return;
            
            const tactic = GameState.selectedTactic;
            const resources = GameState.resources[GameState.currentRole];
            
            // æ‰£é™¤èµ„æº
            Object.keys(tactic.cost).forEach(key => {
                resources[key].value -= tactic.cost[key];
            });
            
            // æ‰§è¡Œæ•ˆæœ
            const result = tactic.effect(GameState);
            
            // è®°å½•æ—¥å¿—
            addActionLog(`${getRoleName(GameState.currentRole)}: ${tactic.name} - ${result.message}`, GameState.currentRole);
            
            // å¤„ç†è¿é”ååº”
            processChainEffects();
            
            // æ£€æŸ¥åŠ¨æ€äº‹ä»¶
            checkDynamicEvents();
            
            // æ›´æ–°ç•Œé¢
            updateResourcePanel();
            updateLayersStatus();
            generateTactics();
            
            // æ¸…é™¤é€‰æ‹©
            GameState.selectedTactic = null;
            document.getElementById('executeBtn').disabled = true;
            
            // ä¸‹ä¸€å›åˆ
            nextRound();
        }
        
        // å¤„ç†è¿é”ååº”
        function processChainEffects() {
            GameState.chainEffects.forEach(effect => {
                if (effect.type === 'cascade' && effect.target) {
                    GameState.layers[effect.target].health -= 15;
                    addIntelligence(`è¿é”ååº”ï¼š${GameState.layers[effect.target].name}å—åˆ°å½±å“`, 'system');
                } else if (effect.type === 'persistent') {
                    Object.keys(GameState.layers).forEach(layer => {
                        GameState.layers[layer].health -= 5;
                    });
                    effect.duration--;
                    if (effect.duration <= 0) {
                        GameState.chainEffects = GameState.chainEffects.filter(e => e !== effect);
                    }
                }
            });
        }
        
        // æ£€æŸ¥åŠ¨æ€äº‹ä»¶
        function checkDynamicEvents() {
            DynamicEvents.forEach(event => {
                if (Math.random() < event.probability && event.condition(GameState)) {
                    const message = event.effect(GameState);
                    showEventModal(event.name, message, 'è¿™å°†å½±å“åç»­å¯¹æŠ—å±€åŠ¿');
                    addIntelligence(`äº‹ä»¶: ${message}`, 'event');
                }
            });
        }
        
        // AIè¡ŒåŠ¨
        function aiAction(role) {
            if (GameState.currentRound > GameState.maxRound) return;
            if (role === GameState.currentRole) return;
            
            const tactics = Tactics[role];
            const resources = GameState.resources[role];
            
            // AIé€‰æ‹©å¯ç”¨çš„æˆ˜æœ¯
            const availableTactics = tactics.filter(t => checkResourceCost(t.cost, resources));
            if (availableTactics.length === 0) {
                addActionLog(`${getRoleName(role)}: èµ„æºä¸è¶³ï¼Œè·³è¿‡å›åˆ`, role);
                return;
            }
            
            // éšæœºé€‰æ‹©ä¸€ä¸ªæˆ˜æœ¯
            const tactic = availableTactics[Math.floor(Math.random() * availableTactics.length)];
            
            // æ‰§è¡Œæˆ˜æœ¯
            Object.keys(tactic.cost).forEach(key => {
                resources[key].value -= tactic.cost[key];
            });
            
            const result = tactic.effect(GameState);
            addActionLog(`${getRoleName(role)}: ${tactic.name} - ${result.message}`, role);
            
            // æ›´æ–°ç•Œé¢
            updateLayersStatus();
            
            // ç»§ç»­AIè¡ŒåŠ¨
            setTimeout(() => aiAction(role), 5000 + Math.random() * 5000);
        }
        
        // ä¸‹ä¸€å›åˆ
        function nextRound() {
            GameState.currentRound++;
            document.getElementById('currentRound').textContent = GameState.currentRound;
            
            // èµ„æºæ¢å¤
            Object.keys(GameState.resources).forEach(role => {
                const resources = GameState.resources[role];
                Object.keys(resources).forEach(key => {
                    resources[key].value = Math.min(
                        resources[key].value + Math.floor(resources[key].max * 0.1),
                        resources[key].max
                    );
                });
            });
            
            // æ£€æŸ¥æ¸¸æˆç»“æŸæ¡ä»¶
            if (checkGameEnd()) {
                endGame();
            }
        }
        
        // æ£€æŸ¥æ¸¸æˆç»“æŸ
        function checkGameEnd() {
            // æ£€æŸ¥æ˜¯å¦æ‰€æœ‰å±‚çº§éƒ½è¢«æ”»ç ´
            const allLayersDown = Object.values(GameState.layers).every(layer => layer.health <= 0);
            if (allLayersDown) {
                GameState.winner = 'attacker';
                return true;
            }
            
            // æ£€æŸ¥æ˜¯å¦è¾¾åˆ°æœ€å¤§å›åˆæ•°
            if (GameState.currentRound >= GameState.maxRound) {
                const totalHealth = Object.values(GameState.layers).reduce((sum, layer) => sum + layer.health, 0);
                const maxTotalHealth = Object.values(GameState.layers).reduce((sum, layer) => sum + layer.maxHealth, 0);
                
                if (totalHealth > maxTotalHealth * 0.6) {
                    GameState.winner = 'defender';
                } else if (totalHealth > maxTotalHealth * 0.3) {
                    GameState.winner = 'monitor';
                } else {
                    GameState.winner = 'attacker';
                }
                return true;
            }
            
            return false;
        }
        
        // æ¸¸æˆç»“æŸ
        function endGame() {
            document.getElementById('game-screen').style.display = 'none';
            document.getElementById('end-screen').style.display = 'block';
            
            const endTitle = document.getElementById('endTitle');
            const isVictory = GameState.winner === GameState.currentRole;
            
            endTitle.className = 'end-title ' + (isVictory ? 'victory' : 'defeat');
            endTitle.textContent = isVictory ? 'ğŸ‰ èƒœåˆ©ï¼' : 'ğŸ’” å¤±è´¥';
            
            // ç»Ÿè®¡æ•°æ®
            const stats = document.getElementById('endStats');
            const totalDamage = Object.values(GameState.layers).reduce(
                (sum, layer) => sum + (layer.maxHealth - layer.health), 0
            );
            
            stats.innerHTML = `
                <div class="stat-item">
                    <span>å¯¹æŠ—å›åˆ</span>
                    <span>${GameState.currentRound}</span>
                </div>
                <div class="stat-item">
                    <span>æœ€ç»ˆèƒœè€…</span>
                    <span>${getRoleName(GameState.winner)}</span>
                </div>
                <div class="stat-item">
                    <span>ç³»ç»Ÿæ€»æŸå¤±</span>
                    <span>${totalDamage.toFixed(0)}</span>
                </div>
                <div class="stat-item">
                    <span>æƒ…æŠ¥æ”¶é›†</span>
                    <span>${GameState.intelligence.length} æ¡</span>
                </div>
                <div class="stat-item">
                    <span>æˆ˜æœ¯æ‰§è¡Œ</span>
                    <span>${GameState.actionLog.filter(log => log.includes(GameState.currentRole)).length} æ¬¡</span>
                </div>
            `;
        }
        
        // è¾…åŠ©å‡½æ•°
        function getRoleName(role) {
            const names = {
                attacker: 'æ”»å‡»æ–¹',
                defender: 'é˜²å®ˆæ–¹',
                monitor: 'ç›‘ç®¡è€…'
            };
            return names[role] || role;
        }
        
        function checkResourceCost(cost, resources) {
            return Object.keys(cost).every(key => resources[key].value >= cost[key]);
        }
        
        function formatCost(cost) {
            return Object.keys(cost).map(key => `${cost[key]}${key}`).join(', ');
        }
        
        function addIntelligence(content, source) {
            const intelList = document.getElementById('intelList');
            const intel = document.createElement('div');
            intel.className = 'intel-item intel-new';
            intel.textContent = content;
            intelList.insertBefore(intel, intelList.firstChild);
            
            // é™åˆ¶æ˜¾ç¤ºæ•°é‡
            while (intelList.children.length > 5) {
                intelList.removeChild(intelList.lastChild);
            }
            
            GameState.intelligence.push({ content, source, round: GameState.currentRound });
            
            setTimeout(() => intel.classList.remove('intel-new'), 3000);
        }
        
        function addActionLog(message, type) {
            const logContainer = document.getElementById('actionLog');
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            entry.textContent = `[å›åˆ${GameState.currentRound}] ${message}`;
            logContainer.insertBefore(entry, logContainer.firstChild);
            
            // é™åˆ¶æ—¥å¿—æ•°é‡
            while (logContainer.children.length > 20) {
                logContainer.removeChild(logContainer.lastChild);
            }
            
            GameState.actionLog.push({ message, type, round: GameState.currentRound });
        }
        
        function showEventModal(title, desc, impact) {
            const modal = document.getElementById('eventModal');
            document.getElementById('eventTitle').textContent = title;
            document.getElementById('eventDesc').textContent = desc;
            document.getElementById('eventImpact').textContent = impact;
            modal.style.display = 'flex';
        }
        
        function closeEventModal() {
            document.getElementById('eventModal').style.display = 'none';
        }
        
        // åˆå§‹åŒ–æ¸¸æˆ
        initGame();
    </script>
</body>
</html>